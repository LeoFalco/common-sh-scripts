#!/usr/bin/bash

set -e


# update refs for new branches and tags
git fetch --tags --force

# remove refs for deleted branches and tags on origin
git remote prune origin

# save current branch for later use
current_branch=$(git rev-parse --abbrev-ref HEAD)

# current branch is not master
if [ "$current_branch" != "master" ]; then
  git branch -D master
  git checkout master
fi


# check if repo ir dirry
if [ -n "$(git status --porcelain)" ]; then
    # if dirty, stop script
    echo "Repo is dirty, please commit or stash changes before running this script"
    exit 1
fi

# switch to master branch
git checkout master
git pull origin master

git checkout $current_branch
git rebase master

# branches_to_rebase=$(git branch | grep -v 'master$')

# if [ ! -z "$branches_to_rebase" ]
# then
#     for branch in $branches_to_rebase
#     do
#         git checkout $branch
#         git rebase master

#         # check if branch is ahead of master
#         if [ "$(git rev-list $branch...master --count)" -gt 0 ]
#         then
#             git push origin $branch -f --no-verify
#         fi
#     done
# fi


# switch to master branch
git checkout master

# list of branches already merged into master
branches_to_delete=$(git branch --merged | grep -v 'master$' | xargs)

echo "Deleting branches:" $branches_to_delete

# if list is not empty
if [ ! -z "$branches_to_delete" ]
then
    # delete the already merged branches
    git branch -D $branches_to_delete
    git push origin --delete $branches_to_delete -f --no-verify 2> /dev/null
fi

# list of existing branches
all_remaining_branches=$(git branch | grep -v 'master$' | xargs)

# check if all remaining branches contains current branch
if [ ! -z "$all_remaining_branches" ]
then
    for branch in $all_remaining_branches
    do
        # if match
        if [ "$branch" = "$current_branch" ]
        then
            # switch back to current branch
            git checkout $current_branch
            break
        fi
    done
fi

echo done